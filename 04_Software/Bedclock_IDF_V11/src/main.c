#include <stdio.h>
#include "driver/i2c.h"
#include "esp_lcd_panel_io.h"
#include "esp_lcd_panel_vendor.h"
#include "esp_lcd_panel_ops.h"
#include "esp_system.h"
#include "esp_lcd_io_i2c.h"
#include "esp_err.h"
#include "esp_log.h"

#include "hp_pixel_buffer.h"
#include "hp_pixel_canvas.h"

#define tag "main"

/*
Different sub-projects to port the Arduino project to ESP-IDF
    Bedclock_IDF_V01 : Test WS2812 led chain
    Bedclock_IDF_V02 : Test SSD1306 OLED screen
    Bedclock_IDF_V03 : Test capacitive touch sensors
    Bedclock_IDF_V04 : Test WiFi
    Bedclock_IDF_V05 : Test time sync with timeserver
    Bedclock_IDF_V06 : Port timer object using esp_timer_get_time() / 1000;
    Bedclock_IDF_V07 : Test FreeRTOS
    Bedclock_IDF_V08 : Implement multiple parallel processes
    Bedclock_IDF_V09 : Internal Espressif SSD1306 driver including LVGL
    Bedclock_IDF_V10 : First working version of application
    Bedclock_IDF_V11 : First working version of pixel buffer
    Bedclock_IDF_V12 : Scrolling example LVGL
*/

#define MN_LCD_H_RES          128
#define MN_LCD_V_RES          32
// #define MN_LCD_V_RES          64
#define MN_I2C_HOST_ID        I2C_NUM_0
#define MN_I2C_SDA_GPIO       21
#define MN_I2C_SCL_GPIO       22
#define MN_LCD_PIXEL_CLOCK_HZ (400 * 1000)
#define MN_I2C_DEV_ADDR       0x3C

uint8_t c_labels_bytes[] = {
    0x06,0x08,0x00,0x00,0x03,0x00,0x06,0x08,0x00,0x00,0x18,0x00,0xf6,0x9c,0xe3,
    0x78,0xbb,0x0d,0xf6,0xdd,0xf7,0x0d,0xbb,0x0d,0xb6,0xcd,0x36,0x3d,0x9b,0x07,
    0xb6,0xcd,0x37,0x61,0x1b,0x07,0xb6,0xdd,0x30,0x7d,0x1b,0x03,0xb6,0x99,0x37,
    0x39,0x33,0x02,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x80,0x01,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,
    0x00,0x00,0x00,0x3e,0xc0,0x00,0x00,0x00,0x00,0x66,0xc0,0x00,0x00,0x00,0x00,
    0x06,0xce,0x9c,0x06,0x00,0x00,0x06,0xdb,0xb6,0x07,0x00,0x00,0x06,0xdb,0xb6,
    0x01,0x00,0x00,0x66,0xdb,0xb6,0x01,0x00,0x00,0x3e,0xdf,0xbe,0x01,0x00,0x00,
    0x18,0x8e,0x9c,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0xdf,0x00,0x00,0x00,0x00,0x00,0xdf,0x00,0x00,0x00,0x00,0x00,0x0c,0xde,0x71,
    0x1a,0x00,0x00,0xcc,0xfe,0xfb,0x1e,0x00,0x00,0xcc,0x36,0xdb,0x06,0x00,0x00,
    0xcc,0x36,0xfb,0x06,0x00,0x00,0xcc,0x36,0x1b,0x06,0x00,0x00,0xcc,0x36,0xf3,
    0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3e,0x03,0x80,
    0x01,0x00,0x00,0x7e,0x03,0x80,0x01,0x00,0x00,0x66,0x00,0x80,0x01,0x00,0x00,
    0x66,0xf3,0x9e,0x79,0x1b,0x00,0x66,0x1b,0xb6,0x61,0x1b,0x00,0x66,0x7b,0xb6,
    0x79,0x0f,0x00,0x66,0xc3,0xb6,0x6d,0x0e,0x00,0x7e,0xfb,0xbe,0x7d,0x0e,0x00,
    0x3e,0x73,0x1e,0x59,0x04,0x00,0x00,0x00,0x06,0x00,0x06,0x00,0x00,0x00,0x06,
    0x00,0x03,0x00 };

uint8_t circle_open_bytes[] = {
    0x00,0x00,0x38,0x00,0x44,0x00,0x82,0x00,0x82,0x00,0x82,0x00,0x44,0x00,0x38,
    0x00,0x00,0x00,0x00,0x00 };

uint8_t circle_closed_bytes[] = {
    0x00,0x00,0x38,0x00,0x7c,0x00,0xfe,0x00,0xfe,0x00,0xfe,0x00,0x7c,0x00,0x38,
    0x00,0x00,0x00,0x00,0x00 };

const hp_bitmap_t labels =        { .width = 48, .height = 48, .buffer = c_labels_bytes };
const hp_bitmap_t circle_open =   { .width = 10, .height = 10, .buffer = circle_open_bytes };
const hp_bitmap_t circle_closed = { .width = 10, .height = 10, .buffer = circle_closed_bytes };

void app_main() {

    const i2c_config_t conf = {
        .mode             = I2C_MODE_MASTER,
        .sda_io_num       = MN_I2C_SDA_GPIO,
        .scl_io_num       = MN_I2C_SCL_GPIO,
        .sda_pullup_en    = GPIO_PULLUP_ENABLE,
        .scl_pullup_en    = GPIO_PULLUP_ENABLE,
        .master.clk_speed = MN_LCD_PIXEL_CLOCK_HZ,
    };

    ESP_ERROR_CHECK(i2c_param_config(MN_I2C_HOST_ID, &conf));

    ESP_ERROR_CHECK(i2c_driver_install(MN_I2C_HOST_ID, I2C_MODE_MASTER, 0, 0, 0));

    esp_lcd_panel_io_handle_t io_handle = NULL;

    esp_lcd_panel_io_i2c_config_t io_config = {
        .dev_addr = MN_I2C_DEV_ADDR,
        .control_phase_bytes = 1,  // According to SSD1306 datasheet
        .dc_bit_offset       = 6,  // According to SSD1306 datasheet
        .lcd_cmd_bits        = 8,  // According to SSD1306 datasheet
        .lcd_param_bits      = 8,  // According to SSD1306 datasheet
    };

    esp_lcd_new_panel_io_i2c( (esp_lcd_i2c_bus_handle_t)MN_I2C_HOST_ID, &io_config, &io_handle);

    esp_lcd_panel_handle_t panel_handle = NULL;

    esp_lcd_panel_ssd1306_config_t esp_lcd_panel_ssd1306_config = {
        .height = 32,
    };

    esp_lcd_panel_dev_config_t panel_config = {
        .bits_per_pixel = 1,
        .reset_gpio_num = -1,
        .vendor_config = &esp_lcd_panel_ssd1306_config,
    };

    esp_lcd_new_panel_ssd1306(io_handle, &panel_config, &panel_handle);
    esp_lcd_panel_reset(panel_handle);
    esp_lcd_panel_init(panel_handle);
    esp_lcd_panel_disp_on_off(panel_handle, true);

    /*
       Initialisation of the display finished
                                            */

    while(true) {
        for(int16_t y=32; y>-90; y--) {

            // Clear the pixel buffer
            hp_bitmap_clear_canvas();

            hp_bitmap_draw_text(50, y, "12:34", 5);
            hp_bitmap_draw_bitmap(&labels, 0, y+20);

            uint16_t variant = 0;

            for(int16_t circle_y=0; circle_y<48; circle_y+=12 )
                for(int16_t circle_x=48; circle_x<48+10*4; circle_x+=10 )
                    hp_bitmap_draw_bitmap( (variant++ % 3 == 0) ? &circle_closed : &circle_open , circle_x, y+20+circle_y);

            // UPload the pixel buffer to the SSD1306
            hp_bitmap_write_canvas(panel_handle);

            vTaskDelay( pdMS_TO_TICKS(15) );
        }
    }

    esp_lcd_panel_del(panel_handle);
    esp_lcd_panel_io_del(io_handle);
    i2c_driver_delete(MN_I2C_HOST_ID);
}